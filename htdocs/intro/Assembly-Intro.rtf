{\rtf1\ansi\deff0
{\fonttbl{\f2\fnil\fcharset0 Courier New;}
{\f1\fnil\fcharset0 Arial;}
{\f0\fnil\fcharset0 Times New Roman;}
}
{\colortbl;}{\stylesheet{\s1 Heading 1;}{\s2 Heading 2;}{\s3 Heading 3;}{\s4 Heading 4;}{\s5 Heading 5;}{\s6 Heading 6;}{\s7 Heading 7;}{\s8 Heading 8;}{\s9 Heading 9;}}
\deflang1024\notabind\facingp\hyphauto1\widowctrl
\sectd\plain\pgwsxn12240\pghsxn15840\marglsxn1440\margrsxn1440\margtsxn1440\margbsxn1920\headery0\footery0\pgndec{\headerl\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}{\footerl\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}{\headerr\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}{\footerr\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}\pard\sb373\sl647\qc \b\fs49\f1 Introduction to UNIX assembly programming\keepn\hyphpar0\par\pard\sb216\sl449\qc \fs34 Konstantin Boldyshev\keepn\hyphpar0\par\pard\sl260\qc \fs24  Linux Assembly (http://linuxassembly.org/) \hyphpar0\par\pard\sb200\sl260\qc            konst@linuxassembly.org\sa0\par\fi0\sb0
        \hyphpar0\par\pard\sb200\li390\ri390\sl260 \b0\fs20\lang1033\f0 This document is intended to be a tutorial, showing how to write a simple assembly program in several UNIX operating systems on the IA-32 (i386) platform. Included material may or may not be applicable to other hardware and/or software platforms.\par\pard\sb100\li390\ri390\sl260 This document explains program layout, system call convention, and the build process.\par\pard\sb100\li390\ri390\sl260 It accompanies the Linux Assembly HOWTO (http://linuxassembly.org/howto.html), which may also be of interest, though it is more Linux specific.\par\pard\sb259\s1\sl449 \b\fs34\lang1024\f1 Table of Contents\keepn\hyphpar0\par\pard\sb173\li480\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_INTRO}{\fldrslt \fs20\f0 1. Introduction}}\fs20\f0 \tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_INTRO}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_INTRO}{\fldrslt 000}}}}\keepn\hyphpar0\par\pard\sb48\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_S_45_LEGAL}{\fldrslt \b0 1.1. Legal blurb}}\b0 \tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_S_45_LEGAL}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_S_45_LEGAL}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _31 }{\fldrslt 1.2. Obtaining this document}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _31 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _31}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _35 }{\fldrslt 1.3. Tools you need}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _35 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _35}{\fldrslt 000}}}}\hyphpar0\par\pard\sb48\li480\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_HELLO}{\fldrslt \b 2. Hello, world!}}\b \tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_HELLO}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_HELLO}{\fldrslt 000}}}}\keepn\hyphpar0\par\pard\sb48\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _54 }{\fldrslt \b0 2.1. System calls}}\b0 \tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _54 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _54}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _76 }{\fldrslt 2.2. Program layout}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _76 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _76}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _85 }{\fldrslt 2.3. Linux}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _85 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _85}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _123 }{\fldrslt 2.4. FreeBSD}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _123 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _123}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _158 }{\fldrslt 2.5. BeOS}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _158 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _158}{\fldrslt 000}}}}\hyphpar0\par\pard\li960\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l _174 }{\fldrslt 2.6. Building an executable}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l _174 }{\fldrslt {\field\flddirty{\*\fldinst PAGEREF _174}{\fldrslt 000}}}}\hyphpar0\par\pard\sb48\li480\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_REF}{\fldrslt \b 3. References}}\b \tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_REF}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_REF}{\fldrslt 000}}}}\keepn\hyphpar0\par\pard\sb48\li480\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_A_45_HISTORY}{\fldrslt A. History}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_A_45_HISTORY}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_A_45_HISTORY}{\fldrslt 000}}}}\keepn\hyphpar0\par\pard\sb48\li480\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_A_45_ACK}{\fldrslt B. Acknowledgements}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_A_45_ACK}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_A_45_ACK}{\fldrslt 000}}}}\keepn\hyphpar0\par\pard\sb48\li480\sl260\fi-480 {\field{\*\fldinst   HYPERLINK  \\l ID_A_45_ENDOR}{\fldrslt C. Endorsements}}\tqr\tldot\tx9360\tab {\field{\*\fldinst   HYPERLINK  \\l ID_A_45_ENDOR}{\fldrslt {\field\flddirty{\*\fldinst PAGEREF ID_A_45_ENDOR}{\fldrslt 000}}}}\hyphpar0\par\sect\sectd\plain\pgwsxn12240\pghsxn15840\marglsxn1440\margrsxn1440\margtsxn1440\margbsxn1920\headery0\footery0\pgndec{\headerl\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}{\footerl\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 \chpgn }\par}{\headerr\pard\sl-240\sb770\sa430\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {}\par}{\footerr\pard\sl-240\sb770\sa910\plain\tqc\tx4680\tqr\tx9360 {}\tab {}\tab {\i\fs20 \chpgn }\par}\pard\sb216\s2\sl374 {\*\bkmkstart ID_INTRO}{\*\bkmkend ID_INTRO}\b\fs28\f1 1. Introduction\keepn\hyphpar0\par\pard\sb200\s3\sl312 {\*\bkmkstart ID_S_45_LEGAL}{\*\bkmkend ID_S_45_LEGAL}\fs24 1.1. Legal blurb\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License (http://www.gnu.org/copyleft/fdl.html) Version 1.1; with no Invariant Sections, with no Front-Cover Texts, and no Back-Cover texts.\par\pard\sb200\s3\sl312 {\*\bkmkstart _31}{\*\bkmkend _31}\b\fs24\lang1024\f1 1.2. Obtaining this document\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 The latest version of this document is available from http://linuxassembly.org/intro.html. If you are reading a few-months-old copy, please check the url above for a new version.\par\pard\sb200\s3\sl312 {\*\bkmkstart _35}{\*\bkmkend _35}\b\fs24\lang1024\f1 1.3. Tools you need\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 You will need several tools to play with programs included in this tutorial.\par\pard\sb100\sl260 First of all you need the assembler (compiler). As a rule modern UNIX distributions include \b as\b0  (or \b gas\b0 ), but all of the examples here use another assembler -- \b nasm\b0  (Netwide Assembler). It comes with full source code, and you can download it from the nasm page (http://sourceforge.net/projects/nasm/), or install it from the ports (or package) system. Compile it, or try to find precompiled binary for your OS; note that several distributions (at least Linux ones) already have \b nasm\b0 , check first.\par\pard\sb100\sl260 Second, you need a linker -- \b ld\b0 , since assembler produces only object code. All distributions with the compilation tools installed will have \b ld\b0 .\par\pard\sb100\sl260 If you're going to dig in, you should also install include files for your OS, and if possible, kernel source.\par\pard\sb100\sl260 Now you should be ready to start, welcome.. \par\pard\sb216\s2\sl374 {\*\bkmkstart ID_HELLO}{\*\bkmkend ID_HELLO}\b\fs28\lang1024\f1 2. Hello, world!\keepn\hyphpar0\par\pard\sb144\sl260 \b0\fs20\lang1033\f0 Now we will write our program, the old classic "Hello, world" (\fs18\f2 hello.asm\fs20\f0 ). You can download its source and binaries here (http://linuxassembly.org/intro/hello.tgz). But before you do, let me explain several basics.\par\pard\sb200\s3\sl312 {\*\bkmkstart _54}{\*\bkmkend _54}\b\fs24\lang1024\f1 2.1. System calls\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 Unless a program is just implementing some math algorithms in assembly, it will deal with such things as getting input, producing output, and exiting. For this, it will need to call on OS services. In fact, programming in assembly language is quite the same in different OSes, unless OS services are touched.\par\pard\sb100\sl260 There are two common ways of performing a system call in UNIX OS: through the C library (libc) wrapper, or directly.\par\pard\sb100\sl260 Using or not using libc in assembly programming is more a question of taste/belief than something practical. Libc wrappers are made to protect programs from possible system call convention changes, and to provide POSIX compatible interface if the kernel lacks it for some call. However, the UNIX kernel is usually more-or-less POSIX compliant -- this means that the syntax of most libc "system calls" exactly matches the syntax of real kernel system calls (and vice versa). But the main drawback of throwing libc away is that one loses several functions that are not just syscall wrappers, like \fs18\f2 printf()\fs20\f0 , \fs18\f2 malloc()\fs20\f0  and similar.\par\pard\sb100\sl260 This tutorial will show how to use \i direct\i0  kernel calls, since this is the fastest way to call kernel service; our code is not linked to any library, does not use ELF interpreter, it communicates with kernel directly.\par\pard\sb100\sl260 Things that differ in different UNIX kernels are set of system calls and system call convention (however as they strive for POSIX compliance, there's a lot of common between them).\par\pard\sb200\li400\sl234 \b\fs18\lang1024\f1 Note: \b0 (Former) DOS programmers might be wondering, "What is a system call?" If you ever wrote a DOS assembly program (and most IA-32 assembly programmers did), you may remember DOS services \fs16\f2 int 0x21\fs18\f1 , \fs16\f2 int 0x25\fs18\f1 , \fs16\f2 int 0x26\fs18\f1  etc.. These are analogous to the UNIX system call. However, the actual implementation is absolutely different, and system calls are not necessarily done via some interrupt. Also, quite often DOS programmers mix OS services with BIOS services like \fs16\f2 int 0x10\fs18\f1  or \fs16\f2 int 0x16\fs18\f1  and are very surprised when they fail to perform them in UNIX, since these are not OS services).\hyphpar0\par\pard\sb200\s3\sl312 {\*\bkmkstart _76}{\*\bkmkend _76}\b\fs24 2.2. Program layout\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 As a rule, modern IA-32 UNIXes are 32bit (*grin*), run in protected mode, have a flat memory model, and use the ELF format for binaries.\par\pard\sb100\sl260 A program can be divided into sections: \fs18\f2 .text\fs20\f0  for your code (read-only), \fs18\f2 .data\fs20\f0  for your data (read-write), \fs18\f2 .bss\fs20\f0  for uninitialized data (read-write); there can actually be a few other standard sections, as well as some user-defined sections, but there's rare need to use them and they are out of our interest here. A program must have at least \fs18\f2 .text\fs20\f0  section.\par\pard\sb100\sl260 Ok, now we'll dive into OS specific details.\par\pard\sb200\s3\sl312 {\*\bkmkstart _85}{\*\bkmkend _85}\b\fs24\lang1024\f1 2.3. Linux\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 System calls in Linux are done through int 0x80. (actually there's a kernel patch allowing system calls to be done via the \fs18\f2 syscall\fs20\f0  (\fs18\f2 sysenter\fs20\f0 ) instruction on newer CPUs, but this thing is still experimental).\par\pard\sb100\sl260 Linux differs from the usual UNIX calling convention, and features a "fastcall" convention for system calls (it resembles DOS). The system function number is passed in \fs18\f2 eax\fs20\f0 , and arguments are passed through registers, not the stack. There can be up to six arguments in \fs18\f2 ebx\fs20\f0 , \fs18\f2 ecx\fs20\f0 , \fs18\f2 edx\fs20\f0 , \fs18\f2 esi\fs20\f0 , \fs18\f2 edi\fs20\f0 , \fs18\f2 ebp\fs20\f0  consequently. If there are more arguments, they are simply passed though the structure as first argument. The result is returned in \fs18\f2 eax\fs20\f0 , and the stack is not touched at all.\par\pard\sb100\sl260 System call function numbers are in \fs18\f2 sys/syscall.h\fs20\f0 , but actually in \fs18\f2 asm/unistd.h\fs20\f0 . Documentation on the actual system calls is in section 2 of the manual pages some documentation is in the 2nd section of manual (for example to find info on \fs18\f2 write\fs20\f0  system call, issue the command \b man 2 write\b0 ).\par\pard\sb100\sl260 There have been several attempts to write an up-to-date documentation of the Linux system calls, examine URLs in the {\field{\*\fldinst   HYPERLINK  \\l ID_REF}{\fldrslt References}} section below.\par\pard\sb100\sl260 So, our Linux program will look like:\par\pard\sb200\sl234 \fs18\f2 section     .text\sa0\par\fi0\sb0
    global _start                       ;must be declared for linker (ld)\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
_start:                                 ;tell linker entry point\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        mov     edx,len ;message length\sa0\par\fi0\sb0
        mov     ecx,msg ;message to write\sa0\par\fi0\sb0
        mov     ebx,1   ;file descriptor (stdout)\sa0\par\fi0\sb0
        mov     eax,4   ;system call number (sys_write)\sa0\par\fi0\sb0
        int     0x80    ;call kernel\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        mov     eax,1   ;system call number (sys_exit)\sa0\par\fi0\sb0
        int     0x80    ;call kernel\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
section .data\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
msg     db      'Hello, world!',0xa     ;our dear string\sa0\par\fi0\sb0
len     equ     $ - msg                 ;length of our dear string\sa0\par\fi0\sb0
\par\pard\sb200\sl260 \fs20\f0 Kernel source references: \par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs18\f2 arch/i386/kernel/entry.S\fs20\f0  (file:///usr/src/linux/arch/i386/kernel/entry.S)\par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs18\f2 include/asm-i386/unistd.h\fs20\f0  (file:///usr/src/linux/include/asm-i386/unistd.h)\par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs18\f2 include/linux/sys.h\fs20\f0  (file:///usr/src/linux/include/linux/sys.h)\par\pard\sb200\s3\sl312 {\*\bkmkstart _123}{\*\bkmkend _123}\b\fs24\lang1024\f1 2.4. FreeBSD\keepn\hyphpar0\par\pard\sb200\li400\sl234 \fs18 Note: \b0 most of this section should apply to other BSD systems (OpenBSD, NetBSD) as well, however the source references may be different.\hyphpar0\par\pard\sb200\sl260 \fs20\lang1033\f0 FreeBSD has the more "usual" calling convention, where the syscall number is in eax, and the parameters are on the stack (the first argument is pushed last). A system call should be done performed through a \i function call\i0  to a function containing \fs18\f2 int 0x80\fs20\f0  and \fs18\f2 ret\fs20\f0 , not just \fs18\f2 int 0x80\fs20\f0  itself (kernel expects to find extra 4 bytes on the stack before \fs18\f2 int 0x80\fs20\f0  is issued). The caller must clean up the stack after the call is complete. The result is returned as usual in \fs18\f2 eax\fs20\f0 .\par\pard\sb100\sl260 There's an alternate way of using \fs18\f2 call 7:0\fs20\f0  gate instead of \fs18\f2 int 0x80\fs20\f0 . The end-result is the same, but the \fs18\f2 call 7:0\fs20\f0  method will increase the program size since you will also need to do an extra \fs18\f2 push eax\fs20\f0  before, and these two instructions occupy more bytes.\par\pard\sb100\sl260 System call function numbers are listed in \fs18\f2 sys/syscall.h\fs20\f0 , and the documentation on the system calls is in section 2 of the man pages.\par\pard\sb100\sl260 Ok, I think the source will explain this better:\par\pard\sb200\sl234 \fs18\f2 section     .text\sa0\par\fi0\sb0
    global _start                       ;must be declared for linker (ld)\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
_syscall:               \sa0\par\fi0\sb0
        int     0x80            ;system call\sa0\par\fi0\sb0
        ret\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
_start:                         ;tell linker entry point\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        push    dword len       ;message length\sa0\par\fi0\sb0
        push    dword msg       ;message to write\sa0\par\fi0\sb0
        push    dword 1         ;file descriptor (stdout)\sa0\par\fi0\sb0
        mov     eax,0x4         ;system call number (sys_write)\sa0\par\fi0\sb0
        call    _syscall        ;call kernel\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
                                ;the alternate way to call kernel:\sa0\par\fi0\sb0
                                ;push   eax\sa0\par\fi0\sb0
                                ;call   7:0\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        add     esp,12          ;clean stack (3 arguments * 4)\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        push    dword 0         ;exit code\sa0\par\fi0\sb0
        mov     eax,0x1         ;system call number (sys_exit)\sa0\par\fi0\sb0
        call    _syscall        ;call kernel\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
                                ;we do not return from sys_exit,\sa0\par\fi0\sb0
                                ;there's no need to clean stack\sa0\par\fi0\sb0
section .data\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
msg     db      "Hello, world!",0xa     ;our dear string\sa0\par\fi0\sb0
len     equ     $ - msg                 ;length of our dear string\sa0\par\fi0\sb0
\par\pard\sb200\sl260 \fs20\f0 Kernel source references: \par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs18\f2 i386/i386/exception.s\fs20\f0  (file:///usr/src/sys/i386/i386/exception.s)\par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs18\f2 i386/i386/trap.c\fs20\f0  (file:///usr/src/sys/i386/i386/trap.c)\par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs18\f2 sys/syscall.h\fs20\f0  (file:///usr/src/sys/sys/syscall.h)\par\pard\sb200\s3\sl312 {\*\bkmkstart _158}{\*\bkmkend _158}\b\fs24\lang1024\f1 2.5. BeOS\keepn\hyphpar0\par\pard\sb200\li400\sl234 \fs18 Note: \b0 if you are building nasm version 0.98 from the source on BeOS, you need to insert \fs16\f2 #include "nasm.h"\fs18\f1  into \fs16\f2 float.h\fs18\f1 , and \fs16\f2 #include <stdio.h>\fs18\f1  into \fs16\f2 nasm.h\fs18\f1 .\hyphpar0\par\pard\sb200\sl260 \fs20\lang1033\f0 The BeOS kernel also uses the "usual" UNIX calling convention. The difference from the FreeBSD example is that you call \fs18\f2 int 0x25\fs20\f0 .\par\pard\sb100\sl260 For information where to find system call function numbers and other interesting details, examine {\field{\*\fldinst   HYPERLINK  \\l ID_REF}{\fldrslt asmutils}}, especially the \fs18\f2 os_beos.inc\fs20\f0  file.\par\pard\sb200\sl234 \fs18\f2 section  .text\sa0\par\fi0\sb0
    global _start                       ;must be declared for linker (ld)\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
_syscall:                       ;system call\sa0\par\fi0\sb0
        int     0x25\sa0\par\fi0\sb0
        ret\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
_start:                         ;tell linker entry point\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        push    dword len       ;message length\sa0\par\fi0\sb0
        push    dword msg       ;message to write\sa0\par\fi0\sb0
        push    dword 1         ;file descriptor (stdout)\sa0\par\fi0\sb0
        mov     eax,0x3         ;system call number (sys_write)\sa0\par\fi0\sb0
        call    _syscall        ;call kernel\sa0\par\fi0\sb0
        add     esp,12          ;clean stack (3 * 4)\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
        push    dword 0         ;exit code\sa0\par\fi0\sb0
        mov     eax,0x3f        ;system call number (sys_exit)\sa0\par\fi0\sb0
        call    _syscall        ;call kernel\sa0\par\fi0\sb0
                                ;no need to clean stack\sa0\par\fi0\sb0
section .data\sa0\par\fi0\sb0
\sa0\par\fi0\sb0
msg     db      "Hello, world!",0xa     ;our dear string\sa0\par\fi0\sb0
len     equ     $ - msg                 ;length of our dear string\sa0\par\fi0\sb0
\par\pard\sb200\s3\sl312 {\*\bkmkstart _174}{\*\bkmkend _174}\b\fs24\lang1024\f1 2.6. Building an executable\keepn\hyphpar0\par\pard\sb120\sl260 \b0\fs20\lang1033\f0 Building an executable is the usual two-step process of compiling and then linking. To make an executable out of our \fs18\f2 hello.asm\fs20\f0  we must do the following:\par\pard\sb200\sl234 \fs18\f2 $ nasm -f elf hello.asm              # this will produce hello.o ELF object file\sa0\par\fi0\sb0
$ ld -s -o hello hello.o        # this will produce hello executable\par\pard\sb200\li400\sl234 \b\lang1024\f1 Note: \b0 OpenBSD and NetBSD users should issue the following sequence instead (because of \fs16\f2 a.out\fs18\f1  executable format):\hyphpar0\par\pard\sb200\li400\sl211 \fs16\f2 $ nasm -f aoutb hello.asm   # this will produce hello.o a.out object file\sa0\par\fi0\sb0
$ ld -e _start -o hello hello.o # this will produce hello executable\hyphpar0\par\pard\sb200\sl260 \fs20\lang1033\f0 That's it. Simple. Now you can launch the hello program by entering \b ./hello\b0 . Look at the binary size -- surprised?\par\pard\sb216\s2\sl374 {\*\bkmkstart ID_REF}{\*\bkmkend ID_REF}\b\fs28\lang1024\f1 3. References\keepn\hyphpar0\par\pard\sb144\sl260 \b0\fs20\lang1033\f0 I hope you enjoyed this journey. If you get interested in assembly programming for UNIX, I strongly encourage you to visit Linux Assembly (http://linuxassembly.org) site for more information, and download the asmutils (http://linuxassembly.org/asmutils.html) package, it contains a lot of sample code. For a comprehensive overview of Linux/UNIX assembly programming refer to the Linux Assembly HOWTO (http://linuxassembly.org/howto.html).\par\pard\sb100\sl260 Thank you for your interest!\par\pard\sb259\s1\sl449 {\*\bkmkstart ID_A_45_HISTORY}{\*\bkmkend ID_A_45_HISTORY}\b\fs34\lang1024\f1 A. History\keepn\hyphpar0\par\pard\sb259\sl260 \fs20\lang1033 Revision History\sa180\par\trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.9\cell \plain \pard\intbl\sl260 \fs20\lang1033 11 Feb 2006\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Linux example correction for 2.6 kernels, updated NASM URL\sa200\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.8\cell \plain \pard\intbl\sl260 \fs20\lang1033 10 Nov 2000\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 rewritten using DocBook DTD, minor corrections\sa200\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.7\cell \plain \pard\intbl\sl260 \fs20\lang1033 23 Aug 2000\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl-200\par\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.6\cell \plain \pard\intbl\sl260 \fs20\lang1033 11 Jul 2000\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl-200\par\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.5\cell \plain \pard\intbl\sl260 \fs20\lang1033 01 Jun 2000\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 merged Daemonnews corrections\sa200\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.3\cell \plain \pard\intbl\sl260 \fs20\lang1033 09 Apr 2000\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 rewritten using linuxdoc dtd\sa200\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.2\cell \plain \pard\intbl\sl260 \fs20\lang1033 26 Jan 2000\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 rearrangement\sa200\cell \row \trowd\trql \clvertalt\cellx3120\clvertalt\cellx6240\clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 Revision 0.1\cell \plain \pard\intbl\sl260 \fs20\lang1033 xx Jun 1999\cell \plain \pard\intbl\sl260 \fs20\lang1033 Revised by: konst\cell \row \trowd\trql \clvertalt\cellx9360 \plain \pard\intbl\sl260 \fs20\lang1033 first version\sa200\cell \row \pard\plain\sl-1\par\pard\sb259\s1\sl449 {\*\bkmkstart ID_A_45_ACK}{\*\bkmkend ID_A_45_ACK}\b\fs34\f1 B. Acknowledgements\keepn\hyphpar0\par\pard\sb173\sl260 \b0\fs20\lang1033\f0 I would like to thank: \par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs20 DaemonNews (http://daemonnews.org) people for proofreading and corrections they kindly submitted to me\par\pard\sb100\li200\sl260\fi-200 \tx200 \fs16 \'95\tab \fs20 Eugene Tsyrklevich (mailto:eugene@securityarchitects.com) for note on NetBSD compile process\par\pard\sb259\s1\sl449 {\*\bkmkstart ID_A_45_ENDOR}{\*\bkmkend ID_A_45_ENDOR}\b\fs34\lang1024\f1 C. Endorsements\keepn\hyphpar0\par\pard\sb173\sl260 \b0\fs20\lang1033\f0 This version of the document is endorsed by {\field{\*\fldinst   HYPERLINK  \\l ID_KONST}{\fldrslt Konstantin Boldyshev}}.\par\pard\sb100\sl260 Modifications (including translations) must remove this appendix according to the {\field{\*\fldinst   HYPERLINK  \\l ID_S_45_LEGAL}{\fldrslt license agreement}}.\par\pard\sb100\sl260 \fs18\f2 $Id: Assembly-Intro.sgml,v 1.9 2006/02/11 08:10:41 konst Exp $\par}
