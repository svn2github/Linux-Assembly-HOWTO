<HTML
><HEAD
><TITLE
>Hello, world!</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Introduction to UNIX assembly programming"
HREF="Assembly-Intro.html"><LINK
REL="PREVIOUS"
TITLE="Introduction to UNIX assembly programming"
HREF="Assembly-Intro.html"><LINK
REL="NEXT"
TITLE="References"
HREF="references.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Introduction to UNIX assembly programming</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="Assembly-Intro.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="references.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="HELLO"
></A
>2. Hello, world!</H1
><P
>Now we will write our program, the old classic "Hello, world"
(<TT
CLASS="FILENAME"
>hello.asm</TT
>).
You can download its source and binaries
<A
HREF="http://linuxassembly.org/intro/hello.tgz"
TARGET="_top"
>here</A
>.
But before you do, let me explain several basics.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN55"
></A
>2.1. System calls</H2
><P
>Unless a program is just implementing some math algorithms in assembly,
it will deal with such things as getting input, producing output,
and exiting. For this, it will need to call on OS services.
In fact, programming in assembly language is quite the same in different OSes,
unless OS services are touched.</P
><P
>There are two common ways of performing a system call in UNIX OS:
through the C library (<SPAN
CLASS="APPLICATION"
>libc</SPAN
>) wrapper, or directly.</P
><P
>Using or not using <SPAN
CLASS="APPLICATION"
>libc</SPAN
> in assembly programming
is more a question of taste/belief than something practical.
<SPAN
CLASS="APPLICATION"
>Libc</SPAN
> wrappers are made to protect programs
from possible system call convention changes,
and to provide POSIX compatible interface if the kernel lacks it for some call.
However, the UNIX kernel is usually more-or-less POSIX compliant --
this means that the syntax of most <SPAN
CLASS="APPLICATION"
>libc</SPAN
> "system calls"
exactly matches the syntax of real kernel system calls (and vice versa).
But the main drawback of throwing <SPAN
CLASS="APPLICATION"
>libc</SPAN
> away
is that one loses several functions that are not just syscall wrappers,
like <TT
CLASS="FUNCTION"
>printf()</TT
>, <TT
CLASS="FUNCTION"
>malloc()</TT
> and similar.</P
><P
>This tutorial will show how to use <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>direct</I
></SPAN
> kernel calls,
since this is the fastest way to call kernel service;
our code is not linked to any library, does not use ELF interpreter,
it communicates with kernel directly.</P
><P
>Things that differ in different UNIX kernels
are set of system calls and system call convention
(however as they strive for POSIX compliance,
there's a lot of common between them).</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>(Former) DOS programmers might be wondering,
"What is a system call?"
If you ever wrote a DOS assembly program
(and most IA-32 assembly programmers did), you may remember DOS services
<TT
CLASS="FUNCTION"
>int 0x21</TT
>,
<TT
CLASS="FUNCTION"
>int 0x25</TT
>,
<TT
CLASS="FUNCTION"
>int 0x26</TT
> etc..
These are analogous to the UNIX system call.
However, the actual implementation is absolutely different,
and system calls are not necessarily done via some interrupt.
Also, quite often DOS programmers mix OS services with BIOS services
like <TT
CLASS="FUNCTION"
>int 0x10</TT
> or <TT
CLASS="FUNCTION"
>int 0x16</TT
>
and are very surprised when they fail
to perform them in UNIX, since these are not OS services).</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN77"
></A
>2.2. Program layout</H2
><P
>As a rule, modern IA-32 UNIXes are 32bit (*grin*), run in protected mode,
have a flat memory model, and use the ELF format for binaries.</P
><P
>A program can be divided into sections:
<TT
CLASS="LITERAL"
>.text</TT
> for your code (read-only),
<TT
CLASS="LITERAL"
>.data</TT
> for your data (read-write),
<TT
CLASS="LITERAL"
>.bss</TT
> for uninitialized data (read-write);
there can actually be a few other standard sections,
as well as some user-defined sections,
but there's rare need to use them and they are out of our interest here.
A program must have at least <TT
CLASS="LITERAL"
>.text</TT
> section.</P
><P
>Ok, now we'll dive into OS specific details.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN86"
></A
>2.3. Linux</H2
><P
>System calls in Linux are done through int 0x80.
(actually there's a kernel patch allowing system calls to be done
via the <TT
CLASS="FUNCTION"
>syscall</TT
> (<TT
CLASS="FUNCTION"
>sysenter</TT
>)
instruction on newer CPUs, but this thing is still experimental).</P
><P
>Linux differs from the usual UNIX calling convention,
and features a "fastcall" convention for system calls (it resembles DOS).
The system function number is passed in <TT
CLASS="LITERAL"
>eax</TT
>,
and arguments are passed through registers, not the stack.
There can be up to six arguments in
<TT
CLASS="LITERAL"
>ebx</TT
>,
<TT
CLASS="LITERAL"
>ecx</TT
>,
<TT
CLASS="LITERAL"
>edx</TT
>,
<TT
CLASS="LITERAL"
>esi</TT
>,
<TT
CLASS="LITERAL"
>edi</TT
>,
<TT
CLASS="LITERAL"
>ebp</TT
> consequently.
If there are more arguments, they are simply passed though the
structure as first argument.
The result is returned in <TT
CLASS="LITERAL"
>eax</TT
>,
and the stack is not touched at all.</P
><P
>System call function numbers are in <TT
CLASS="FILENAME"
>sys/syscall.h</TT
>,
but actually in <TT
CLASS="FILENAME"
>asm/unistd.h</TT
>.
Documentation on the actual system calls is in section 2 of the manual pages
some documentation is in the 2nd section of manual
(for example to find info on <TT
CLASS="FUNCTION"
>write</TT
> system call,
issue the command <B
CLASS="COMMAND"
>man 2 write</B
>).</P
><P
>There have been several attempts to write
an up-to-date documentation of the Linux system calls,
examine URLs in the <A
HREF="references.html"
>References</A
> section below.</P
><P
>So, our Linux program will look like:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>section	.text
    global _start			;must be declared for linker (ld)

_start:					;tell linker entry point

	mov	edx,len	;message length
	mov	ecx,msg	;message to write
	mov	ebx,1	;file descriptor (stdout)
	mov	eax,4	;system call number (sys_write)
	int	0x80	;call kernel

	mov	eax,1	;system call number (sys_exit)
	int	0x80	;call kernel

section	.data

msg	db	'Hello, world!',0xa	;our dear string
len	equ	$ - msg			;length of our dear string&#13;</PRE
></P
><P
>Kernel source references:

<P
></P
><UL
><LI
><P
><A
HREF="file:///usr/src/linux/arch/i386/kernel/entry.S"
TARGET="_top"
><TT
CLASS="FILENAME"
>arch/i386/kernel/entry.S</TT
></A
></P
></LI
><LI
><P
><A
HREF="file:///usr/src/linux/include/asm-i386/unistd.h"
TARGET="_top"
><TT
CLASS="FILENAME"
>include/asm-i386/unistd.h</TT
></A
></P
></LI
><LI
><P
><A
HREF="file:///usr/src/linux/include/linux/sys.h"
TARGET="_top"
><TT
CLASS="FILENAME"
>include/linux/sys.h</TT
></A
></P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN124"
></A
>2.4. FreeBSD</H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>most of this section should apply to other BSD systems (OpenBSD, NetBSD) as well,
however the source references may be different.</P
></BLOCKQUOTE
></DIV
><P
>FreeBSD has the more "usual" calling convention,
where the syscall number is in eax, and the parameters are on the stack
(the first argument is pushed last).
A system call should be done performed through a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>function call</I
></SPAN
>
to a function containing
<TT
CLASS="FUNCTION"
>int 0x80</TT
> and <TT
CLASS="FUNCTION"
>ret</TT
>,
not just <TT
CLASS="FUNCTION"
>int 0x80</TT
> itself
(kernel expects to find extra 4 bytes on the stack
before <TT
CLASS="FUNCTION"
>int 0x80</TT
> is issued).
The caller must clean up the stack after the call is complete.
The result is returned as usual in <TT
CLASS="LITERAL"
>eax</TT
>.</P
><P
>There's an alternate way of using <TT
CLASS="FUNCTION"
>call 7:0</TT
> gate
instead of <TT
CLASS="FUNCTION"
>int 0x80</TT
>.
The end-result is the same, but the <TT
CLASS="FUNCTION"
>call 7:0</TT
>
method will increase the program size
since you will also need to do an extra <TT
CLASS="FUNCTION"
>push eax</TT
> before,
and these two instructions occupy more bytes.</P
><P
>System call function numbers are listed in <TT
CLASS="FILENAME"
>sys/syscall.h</TT
>,
and the documentation on the system calls is in section 2 of the man pages.</P
><P
>Ok, I think the source will explain this better:</P
><P
><PRE
CLASS="PROGRAMLISTING"
>section	.text
    global _start			;must be declared for linker (ld)

_syscall:		
	int	0x80		;system call
	ret

_start:				;tell linker entry point

	push	dword len	;message length
	push	dword msg	;message to write
	push	dword 1		;file descriptor (stdout)
	mov	eax,0x4		;system call number (sys_write)
	call	_syscall	;call kernel

				;the alternate way to call kernel:
				;push	eax
				;call	7:0

	add	esp,12		;clean stack (3 arguments * 4)

	push	dword 0		;exit code
	mov	eax,0x1		;system call number (sys_exit)
	call	_syscall	;call kernel

				;we do not return from sys_exit,
				;there's no need to clean stack
section	.data

msg	db	"Hello, world!",0xa	;our dear string
len	equ	$ - msg			;length of our dear string&#13;</PRE
></P
><P
>Kernel source references:

<P
></P
><UL
><LI
><P
><A
HREF="file:///usr/src/sys/i386/i386/exception.s"
TARGET="_top"
><TT
CLASS="FILENAME"
>i386/i386/exception.s</TT
></A
></P
></LI
><LI
><P
><A
HREF="file:///usr/src/sys/i386/i386/trap.c"
TARGET="_top"
><TT
CLASS="FILENAME"
>i386/i386/trap.c</TT
></A
></P
></LI
><LI
><P
><A
HREF="file:///usr/src/sys/sys/syscall.h"
TARGET="_top"
><TT
CLASS="FILENAME"
>sys/syscall.h</TT
></A
></P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN159"
></A
>2.5. BeOS</H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>if you are building <SPAN
CLASS="APPLICATION"
>nasm</SPAN
> version 0.98
from the source on BeOS,
you need to insert <TT
CLASS="LITERAL"
>#include "nasm.h"</TT
>
into <TT
CLASS="FILENAME"
>float.h</TT
>,
and <TT
CLASS="LITERAL"
>#include &#60;stdio.h&#62;</TT
>
into <TT
CLASS="FILENAME"
>nasm.h</TT
>.</P
></BLOCKQUOTE
></DIV
><P
>The BeOS kernel also uses the "usual" UNIX calling convention.
The difference from the FreeBSD example is that you call
<TT
CLASS="FUNCTION"
>int 0x25</TT
>.</P
><P
>For information where to find system call function numbers and other
interesting details, examine <A
HREF="references.html"
>asmutils</A
>,
especially the <TT
CLASS="FILENAME"
>os_beos.inc</TT
> file.</P
><P
><PRE
CLASS="PROGRAMLISTING"
>section	.text
    global _start			;must be declared for linker (ld)

_syscall:			;system call
	int	0x25
	ret

_start:				;tell linker entry point

	push	dword len	;message length
	push	dword msg	;message to write
	push	dword 1		;file descriptor (stdout)
	mov	eax,0x3		;system call number (sys_write)
	call	_syscall	;call kernel
	add	esp,12		;clean stack (3 * 4)

	push	dword 0		;exit code
	mov	eax,0x3f	;system call number (sys_exit)
	call	_syscall	;call kernel
				;no need to clean stack
section	.data

msg	db	"Hello, world!",0xa	;our dear string
len	equ	$ - msg			;length of our dear string&#13;</PRE
></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN175"
></A
>2.6. Building an executable</H2
><P
>Building an executable is the usual two-step process of compiling and then linking.
To make an executable out of our <TT
CLASS="FILENAME"
>hello.asm</TT
> we must do the following:</P
><P
><PRE
CLASS="SCREEN"
>$ nasm -f elf hello.asm		# this will produce hello.o ELF object file
$ ld -s -o hello hello.o	# this will produce hello executable</PRE
></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>OpenBSD and NetBSD users should issue the following sequence instead
(because of <TT
CLASS="LITERAL"
>a.out</TT
> executable format):</P
><P
><PRE
CLASS="SCREEN"
>$ nasm -f aoutb hello.asm	# this will produce hello.o a.out object file
$ ld -e _start -o hello hello.o	# this will produce hello executable</PRE
></P
></BLOCKQUOTE
></DIV
><P
>That's it. Simple.
Now you can launch the hello program by entering <B
CLASS="COMMAND"
>./hello</B
>.
Look at the binary size -- surprised?</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="Assembly-Intro.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="Assembly-Intro.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="references.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Introduction to UNIX assembly programming</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>References</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>